# -*- coding: utf-8 -*-
"""Limpieza_Datos_Estudiantes_Ingenieria

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MuemS4LgfoI2shSxaJLOORG7Jx5Y6ZRO
"""

from google.colab import files
uploaded = files.upload()

import pandas as pd
import numpy as np
import unicodedata
import re

nombre_archivo = 'estudiantes_ingenieria_con_errores.xlsx'
try:
    df = pd.read_excel(nombre_archivo)
    print("Archivo cargado exitosamente.")
except FileNotFoundError:
    print(f"Error: El archivo '{nombre_archivo}' no fue encontrado. Asegúrate de haberlo subido y que el nombre sea correcto.")
except Exception as e:
    print(f"Ocurrió un error al cargar el archivo: {e}")

print("Primeras 5 filas del DataFrame original:")
print(df.head())

print("\nInformación general del DataFrame original:")
df.info()

print("\nResumen estadístico original:")
print(df.describe(include='all'))

"""**Analisis de los resultado del DataFrame**

*   El archivo se cargó correctamente.
*   Se observa una fila inicial completamente vacía (llena de NaN).
*   Los nombres de las columnas tienen mayúsculas, espacios y tildes (ej. "Nombre del Estudiante", "Costo Matrícula").
*   La columna "Ciudad de Nacimiento" muestra caracteres extraños (ej. "MonterÃ­a"), lo que sugiere un problema de codificación o tipeo.
*   La columna "Edad" está como float64, probablemente por los NaN. Debería ser un entero.
*   Las columnas "Proyectos de Investigación" e "Interés estudiar posgrado" tienen valores como "SI" y "sÍ", necesitan estandarizarse.
*   "Costo Matrícula" y "Promedio Actual" parecen numéricos pero podrían tener formatos inconsistentes no visibles en las primeras 5 filas.

"""

print(f"Filas antes de eliminar vacías: {len(df)}")
df.dropna(how='all', inplace=True)
print(f"Filas después de eliminar vacías: {len(df)}")

df.replace(['*', '#N/A', 'N/D', 'nan', ''], np.nan, inplace=True)
print("Placeholders comunes como '*', 'N/D', cadenas vacías y 'nan' (texto) reemplazados por np.nan.")

if 'Costo Matrícula' in df.columns:
    df['Costo Matrícula'] = df['Costo Matrícula'].astype(str)
    # Eliminar puntos (que podrían ser separadores de miles)
    df['Costo Matrícula'] = df['Costo Matrícula'].str.replace('.', '', regex=False)
    print("Puntos eliminados de 'Costo Matrícula' (si existían). La conversión a numérico se hará en el Paso 4.")
else:
    print("Columna 'Costo Matrícula' no encontrada con ese nombre exacto.")

if 'Promedio Actual' in df.columns: # Uso el nombre original
    df['Promedio Actual'] = df['Promedio Actual'].astype(str)
    df['Promedio Actual'] = df['Promedio Actual'].str.replace(',', '.', regex=False)
    print("Comas reemplazadas por puntos en 'Promedio Actual' (si existían). La conversión a numérico se hará en el Paso 4.")
else:
    print("Columna 'Promedio Actual' no encontrada con ese nombre exacto.")

"""**Eliminación de Registros No Válidos y Correcciones Iniciales**

*   Se eliminaron las filas completamente vacías.
*   Se reemplazaron placeholders comunes ('*', 'N/D', 'nan' como texto, cadenas vacías) por `np.nan`.
*   Se preparó el código para eliminar puntos de 'Costo Matrícula' y estandarizar decimales en 'Promedio Actual', aunque en la muestra inicial estos problemas no eran evidentes, se sigue la guía del ejercicio.
"""

print("Nombres de columnas originales:", df.columns.tolist())

def limpiar_nombre_columna(col_name):
    col_name = str(col_name).lower() #Convertir a minúsculas
#Quitar tildes y caracteres diacríticos
    col_name = unicodedata.normalize('NFKD', col_name).encode('ascii', 'ignore').decode('utf-8')
#Reemplazar espacios con guion bajo
    col_name = col_name.replace(' ', '_')
#Eliminar cualquier caracter que no sea letra minúscula, número o guion bajo
    col_name = re.sub(r'[^a-z0-9_]', '', col_name)
    return col_name

df.columns = [limpiar_nombre_columna(col) for col in df.columns]
print("Nombres de columnas estandarizados:", df.columns.tolist())

if 'nombre_del_estudiante' in df.columns:
    df['nombre_del_estudiante'] = df['nombre_del_estudiante'].astype(str) # Asegurar que sea texto

    split_names = df['nombre_del_estudiante'].str.split(' ', n=1, expand=True)

    df['nombres'] = split_names[0] # La primera parte es el nombre
    df['apellidos'] = split_names[1] # La segunda parte (el resto) son los apellidos

    # Limpiar posibles 'nan' de texto que resultaron de la conversión a string
    df.loc[df['nombres'] == 'nan', 'nombres'] = np.nan
    df.loc[df['apellidos'] == 'nan', 'apellidos'] = np.nan
    df.loc[df['apellidos'].isnull(), 'apellidos'] = np.nan # Si no hubo segundo nombre/apellido, asegurar que sea NaN

    print("Columna 'nombre_del_estudiante' separada en 'nombres' y 'apellidos'.")
    print("Primeras filas de las nuevas columnas 'nombres' y 'apellidos':")
    print(df[['nombres', 'apellidos']].head())

else:
    print("Columna 'nombre_del_estudiante' no encontrada para separación.")

print("\nTipos de datos después de estandarizar nombres y separar (antes de limpieza específica por columna):")
df.info()

"""Paso 3: Estandarización de Columnas

*   Los nombres de las columnas se convirtieron a minúsculas, se quitaron tildes y caracteres especiales, y los espacios se reemplazaron por guiones bajos.
*   La columna `nombre_del_estudiante` se separó en `nombres` y `apellidos`.
*   Se revisaron los tipos de datos preliminarmente. La corrección final de tipos se hará en el siguiente paso.
"""

if 'edad' in df.columns:

    df['edad'] = pd.to_numeric(df['edad'], errors='coerce')

    df.loc[(df['edad'] <= 10) | (df['edad'] > 80), 'edad'] = np.nan
    df['edad'] = df['edad'].astype('Int64')

    print("Columna 'edad' limpiada.")
    print("Valores únicos en 'edad' (muestra):", df['edad'].unique()[:20]) # Muestra los primeros 20 valores únicos
    print("Descripción de 'edad':")
    print(df['edad'].describe())
else:
    print("Columna 'edad' no encontrada.")

if 'genero' in df.columns:

    df['genero'] = df['genero'].astype(str).str.strip().str.upper()

    genero_map = {
        'F': 'F', 'FEMENINO': 'F', 'MUJER': 'F', # Valores para Femenino
        'M': 'M', 'MASCULINO': 'M', 'HOMBRE': 'M', # Valores para Masculino
        'NAN': np.nan # Si 'nan' (texto) quedó de la conversión a str
    }
    df['genero'] = df['genero'].replace(genero_map)


    df.loc[~df['genero'].isin(['M', 'F']), 'genero'] = np.nan

    print("Columna 'genero' limpiada.")
    print("Valores únicos en 'genero':", df['genero'].unique())
    print("Conteo de valores en 'genero':")
    print(df['genero'].value_counts(dropna=False)) # dropna=False para incluir conteo de NaN
else:
    print("Columna 'genero' no encontrada.")

if 'ciudad_de_nacimiento' in df.columns:
    df['ciudad_de_nacimiento'] = df['ciudad_de_nacimiento'].astype(str).str.strip()

    def corregir_ciudad(ciudad_str):
        if pd.isna(ciudad_str) or ciudad_str.lower() == 'nan':
            return np.nan

        ciudad_str = ciudad_str.replace('Ã\xada', 'ía').replace('Ã©', 'é')
        ciudad_str = ciudad_str.replace('Ã¡', 'á').replace('Ã³', 'ó')
        ciudad_str = ciudad_str.replace('Ãº', 'ú').replace('Ã±', 'ñ')
        ciudad_str = ciudad_str.replace('MonterÃ­a', 'Montería')
        ciudad_str = ciudad_str.replace('BogotÃ¡', 'Bogotá')

        correcciones_ciudad_map = {
            'bogota d.c.': 'Bogotá', # Estandarizar a Bogotá con tilde
            'sta marta': 'Santa Marta',
            'monteria': 'Montería', # Si después de la corrección de arriba queda sin tilde
            'yumbo': 'Yumbo'
        }
        ciudad_lower_temp = ciudad_str.lower() # Convertir a minúscula para buscar en el mapa
        if ciudad_lower_temp in correcciones_ciudad_map:
            ciudad_str = correcciones_ciudad_map[ciudad_lower_temp]

        ciudad_str = re.sub(r'[^a-zA-ZáéíóúÁÉÍÓÚñÑ\s]', '', ciudad_str).strip()

        # Capitalizar la primera letra de cada palabra (ej. "santa marta" -> "Santa Marta")
        return ciudad_str.title() if ciudad_str else np.nan

    df['ciudad_de_nacimiento'] = df['ciudad_de_nacimiento'].apply(corregir_ciudad)
    df.loc[df['ciudad_de_nacimiento'] == '', 'ciudad_de_nacimiento'] = np.nan

    print("Columna 'ciudad_de_nacimiento' limpiada.")
    print("Valores únicos en 'ciudad_de_nacimiento' (muestra de los más frecuentes):")
    print(df['ciudad_de_nacimiento'].value_counts().head(10)) # Muestra los 10 más frecuentes
else:
    print("Columna 'ciudad_de_nacimiento' no encontrada.")

if 'semestre' in df.columns:
    df['semestre'] = pd.to_numeric(df['semestre'], errors='coerce')
    # Validar que esté entre 1 y 10 (o el máximo del plan de estudios)
    df.loc[(df['semestre'] < 1) | (df['semestre'] > 10), 'semestre'] = np.nan # Se toma como referencias que 10 semestre es lo maximo.
    df['semestre'] = df['semestre'].astype('Int64')

    print("Columna 'semestre' limpiada.")
    print("Valores únicos en 'semestre':", df['semestre'].unique())
    print("Descripción de 'semestre':")
    print(df['semestre'].describe())
else:
    print("Columna 'semestre' no encontrada.")

if 'promedio_actual' in df.columns:

    df['promedio_actual'] = df['promedio_actual'].astype(str)
    df['promedio_actual'] = df['promedio_actual'].str.replace(',', '.', regex=False)
    df['promedio_actual'] = pd.to_numeric(df['promedio_actual'], errors='coerce')
    df.loc[(df['promedio_actual'] < 0) | (df['promedio_actual'] > 5), 'promedio_actual'] = np.nan

    print("Columna 'promedio_actual' limpiada.")
    print("Descripción de 'promedio_actual':")
    print(df['promedio_actual'].describe())
else:
    print("Columna 'promedio_actual' no encontrada.")

if 'costo_matricula' in df.columns:

    df['costo_matricula'] = df['costo_matricula'].astype(str)
    df['costo_matricula'] = df['costo_matricula'].str.replace('.', '', regex=False) # Para separadores de miles
    df['costo_matricula'] = df['costo_matricula'].str.replace('$', '', regex=False) # Símbolo de peso
    df['costo_matricula'] = df['costo_matricula'].str.replace(r'[^\d]', '', regex=True)
    df['costo_matricula'] = pd.to_numeric(df['costo_matricula'], errors='coerce')

    df['costo_matricula'] = df['costo_matricula'].astype('Int64')

    print("Columna 'costo_matricula' limpiada.")
    print("Descripción de 'costo_matricula':")
    print(df['costo_matricula'].describe())
else:
    print("Columna 'costo_matricula' no encontrada.")

"""Limpieza Específica por Columna

*   **edad:** Convertida a numérico Int64, valores fuera de rango (<=10 o >80) a NaN.
*   **genero:** Estandarizado a 'M', 'F', o NaN.
*   **ciudad_de_nacimiento:** Se corrigieron caracteres especiales (ej. 'MonterÃ­a' a 'Montería'), se eliminaron caracteres no alfabéticos y se capitalizó.
*   **semestre:** Convertido a numérico Int64, valores fuera de rango (1-10) a NaN.
*   **promedio_actual:** Convertido a numérico float, comas reemplazadas por puntos, valores fuera de rango (0-5) a NaN.
*   **costo_matricula:** Convertido a numérico Int64, eliminados puntos y símbolos de moneda.
"""

print("\nDataFrame final (primeras 5 filas):")
print(df.head())

print("\nInformación del DataFrame final:")
df.info()

print("\nResumen estadístico del DataFrame final:")
print(df.describe(include='all'))

print("\nConteo de valores NaN por columna en el DataFrame final:")
print(df.isnull().sum())

nombre_archivo_limpio = 'estudiantes_ingenieria_limpios.xlsx'
df_para_guardar = df.copy()
df_para_guardar.to_excel(nombre_archivo_limpio, index=False)
print(f"\nArchivo limpio guardado en el entorno de Colab como '{nombre_archivo_limpio}'")

from google.colab import files
files.download(nombre_archivo_limpio)

"""**Paso 5: Generación del Archivo Limpio**

*   Se revisó el DataFrame final (primeras filas, información general, estadísticas y conteo de NaNs).
*   El DataFrame limpio se guardó en el archivo `estudiantes_ingenieria_limpios.xlsx`.
*   El archivo `estudiantes_ingenieria_limpios.xlsx` fue descargado a la computadora local.


"""